{"version":3,"file":"AssetsController.js","sourceRoot":"","sources":["../../src/assets/AssetsController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { toChecksumAddress } from 'ethereumjs-util';\nimport BaseController, { BaseConfig, BaseState } from '../BaseController';\nimport PreferencesController from '../user/PreferencesController';\nimport NetworkController, { NetworkType } from '../network/NetworkController';\nimport { safelyExecute, handleFetch, validateTokenToWatch } from '../util';\nimport { Token } from './TokenRatesController';\nimport { AssetsContractController } from './AssetsContractController';\nimport { ApiCollectibleResponse } from './AssetsDetectionController';\n\nconst { Mutex } = require('await-semaphore');\nconst random = require('uuid/v1');\n\n/**\n * @type Collectible\n *\n * Collectible representation\n *\n * @property address - Hex address of a ERC721 contract\n * @property description - The collectible description\n * @property image - URI of custom collectible image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The collectible identifier\n */\nexport interface Collectible {\n  address: string;\n  description?: string;\n  image?: string;\n  name?: string;\n  tokenId: number;\n}\n\n/**\n * @type CollectibleContract\n *\n * Collectible contract information representation\n *\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Contract total supply\n */\nexport interface CollectibleContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n}\n\n/**\n * @type ApiCollectibleContractResponse\n *\n * Collectible contract object coming from OpenSea api\n *\n * @property description - The collectible identifier\n * @property image_url - URI of collectible image associated with this collectible\n * @property name - The collectible name\n * @property description - The collectible description\n * @property total_supply - Contract total supply\n */\nexport interface ApiCollectibleContractResponse {\n  description?: string;\n  image_url?: string;\n  name?: string;\n  symbol?: string;\n  total_supply?: string;\n}\n\n/**\n * @type CollectibleInformation\n *\n * Collectible custom information\n *\n * @property description - The collectible description\n * @property name - Collectible custom name\n * @property image - Image custom image URI\n */\nexport interface CollectibleInformation {\n  description?: string;\n  image?: string;\n  name?: string;\n}\n\n/**\n * @type AssetsConfig\n *\n * Assets controller configuration\n *\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface AssetsConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n}\n\n/**\n * @type AssetSuggestionResult\n *\n * @property result - Promise resolving to a new suggested asset address\n * @property suggestedAssetMeta - Meta information about this new suggested asset\n */\nexport interface AssetSuggestionResult {\n  result: Promise<string>;\n  suggestedAssetMeta: SuggestedAssetMeta;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n *\n * @property error - Synthesized error information for failed asset suggestions\n * @property id - Generated UUID associated with this suggested asset\n * @property status - String status of this this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n */\nexport interface SuggestedAssetMeta {\n  error?: {\n    message: string;\n    stack?: string;\n  };\n  id: string;\n  status: string;\n  time: number;\n  type: string;\n  asset: Token;\n}\n\n/**\n * @type AssetsState\n *\n * Assets controller state\n *\n * @property allTokens - Object containing tokens per account and network\n * @property allCollectibleContracts - Object containing collectibles contract information\n * @property allCollectibles - Object containing collectibles per account and network\n * @property collectibleContracts - List of collectibles contracts associated with the active vault\n * @property collectibles - List of collectibles associated with the active vault\n * @property suggestedAssets - List of suggested assets associated with the active vault\n * @property tokens - List of tokens associated with the active vault\n * @property ignoredTokens - List of tokens that should be ignored\n * @property ignoredCollectibles - List of collectibles that should be ignored\n */\nexport interface AssetsState extends BaseState {\n  allTokens: { [key: string]: { [key: string]: Token[] } };\n  allCollectibleContracts: { [key: string]: { [key: string]: CollectibleContract[] } };\n  allCollectibles: { [key: string]: { [key: string]: Collectible[] } };\n  collectibleContracts: CollectibleContract[];\n  collectibles: Collectible[];\n  ignoredTokens: Token[];\n  ignoredCollectibles: Collectible[];\n  suggestedAssets: SuggestedAssetMeta[];\n  tokens: Token[];\n}\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class AssetsController extends BaseController<AssetsConfig, AssetsState> {\n  private mutex = new Mutex();\n\n  private getCollectibleApi(contractAddress: string, tokenId: number) {\n    return `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getCollectibleContractInformationApi(contractAddress: string) {\n    return `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;\n  }\n\n  private failSuggestedAsset(suggestedAssetMeta: SuggestedAssetMeta, error: Error) {\n    suggestedAssetMeta.status = 'failed';\n    suggestedAssetMeta.error = {\n      message: error.toString(),\n      stack: error.stack,\n    };\n    this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n  }\n\n  /**\n   * Get collectible tokenURI API following ERC721\n   *\n   * @param contractAddress - ERC721 asset contract address\n   * @param tokenId - ERC721 asset identifier\n   * @returns - Collectible tokenURI\n   */\n  private async getCollectibleTokenURI(contractAddress: string, tokenId: number): Promise<string> {\n    const assetsContract = this.context.AssetsContractController as AssetsContractController;\n    const supportsMetadata = await assetsContract.contractSupportsMetadataInterface(contractAddress);\n    /* istanbul ignore if */\n    if (!supportsMetadata) {\n      return '';\n    }\n    const tokenURI = await assetsContract.getCollectibleTokenURI(contractAddress, tokenId);\n    return tokenURI;\n  }\n\n  /**\n   * Request individual collectible information from OpenSea api\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @param tokenId - The collectible identifier\n   * @returns - Promise resolving to the current collectible name and image\n   */\n  private async getCollectibleInformationFromApi(\n    contractAddress: string,\n    tokenId: number,\n  ): Promise<CollectibleInformation> {\n    const tokenURI = this.getCollectibleApi(contractAddress, tokenId);\n    let collectibleInformation: ApiCollectibleResponse;\n    /* istanbul ignore if */\n    if (this.openSeaApiKey) {\n      collectibleInformation = await handleFetch(tokenURI, { headers: { 'X-API-KEY': this.openSeaApiKey } });\n    } else {\n      collectibleInformation = await handleFetch(tokenURI);\n    }\n    const { name, description, image_original_url } = collectibleInformation;\n    return { image: image_original_url, name, description };\n  }\n\n  /**\n   * Request individual collectible information from contracts that follows Metadata Interface\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @param tokenId - The collectible identifier\n   * @returns - Promise resolving to the current collectible name and image\n   */\n  private async getCollectibleInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: number,\n  ): Promise<CollectibleInformation> {\n    const tokenURI = await this.getCollectibleTokenURI(contractAddress, tokenId);\n    const object = await handleFetch(tokenURI);\n    const image = object.hasOwnProperty('image') ? 'image' : /* istanbul ignore next */ 'image_url';\n    return { image: object[image], name: object.name };\n  }\n\n  /**\n   * Request individual collectible information (name, image url and description)\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @param tokenId - The collectible identifier\n   * @returns - Promise resolving to the current collectible name and image\n   */\n  private async getCollectibleInformation(contractAddress: string, tokenId: number): Promise<CollectibleInformation> {\n    let information;\n    // First try with OpenSea\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleInformationFromApi(contractAddress, tokenId);\n    });\n    if (information) {\n      return information;\n    }\n    // Then following ERC721 standard\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);\n    });\n    /* istanbul ignore next */\n    if (information) {\n      return information;\n    }\n    /* istanbul ignore next */\n    return {};\n  }\n\n  /**\n   * Request collectible contract information from OpenSea api\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @returns - Promise resolving to the current collectible name and image\n   */\n  private async getCollectibleContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContractResponse> {\n    const api = this.getCollectibleContractInformationApi(contractAddress);\n    let collectibleContractObject;\n    /* istanbul ignore if */\n    if (this.openSeaApiKey) {\n      collectibleContractObject = await handleFetch(api, { headers: { 'X-API-KEY': this.openSeaApiKey } });\n    } else {\n      collectibleContractObject = await handleFetch(api);\n    }\n    const { name, symbol, image_url, description, total_supply } = collectibleContractObject;\n    return { name, symbol, image_url, description, total_supply };\n  }\n\n  /**\n   * Request collectible contract information from the contract itself\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @returns - Promise resolving to the current collectible name and image\n   */\n  private async getCollectibleContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContractResponse> {\n    const assetsContractController = this.context.AssetsContractController as AssetsContractController;\n    const name = await assetsContractController.getAssetName(contractAddress);\n    const symbol = await assetsContractController.getAssetSymbol(contractAddress);\n    return { name, symbol };\n  }\n\n  /**\n   * Request collectible contract information from OpenSea api\n   *\n   * @param contractAddress - Hex address of the collectible contract\n   * @returns - Promise resolving to the collectible contract name, image and description\n   */\n  private async getCollectibleContractInformation(contractAddress: string): Promise<ApiCollectibleContractResponse> {\n    let information;\n    // First try with OpenSea\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleContractInformationFromApi(contractAddress);\n    });\n    if (information) {\n      return information;\n    }\n    // Then following ERC721 standard\n    information = await safelyExecute(async () => {\n      return await this.getCollectibleContractInformationFromContract(contractAddress);\n    });\n    if (information) {\n      return information;\n    }\n    /* istanbul ignore next */\n    return {};\n  }\n\n  /**\n   * Adds an individual collectible to the stored collectible list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - The collectible identifier\n   * @param opts - Collectible optional information (name, image and description)\n   * @returns - Promise resolving to the current collectible list\n   */\n  private async addIndividualCollectible(\n    address: string,\n    tokenId: number,\n    opts?: CollectibleInformation,\n  ): Promise<Collectible[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumAddress(address);\n      const { allCollectibles, collectibles } = this.state;\n      const { networkType, selectedAddress } = this.config;\n      const existingEntry = collectibles.find(\n        (collectible) => collectible.address === address && collectible.tokenId === tokenId,\n      );\n      if (existingEntry) {\n        return collectibles;\n      }\n      const { name, image, description } = opts || (await this.getCollectibleInformation(address, tokenId));\n      const newEntry: Collectible = { address, tokenId, name, image, description };\n      const newCollectibles = [...collectibles, newEntry];\n      const addressCollectibles = allCollectibles[selectedAddress];\n      const newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n      const newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n      this.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });\n      return newCollectibles;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a collectible contract to the stored collectible contracts list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param detection? - Whether the collectible is manually added or auto-detected\n   * @returns - Promise resolving to the current collectible contracts list\n   */\n  private async addCollectibleContract(address: string, detection?: boolean): Promise<CollectibleContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumAddress(address);\n      const { allCollectibleContracts, collectibleContracts } = this.state;\n      const { networkType, selectedAddress } = this.config;\n      const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address === address);\n      if (existingEntry) {\n        return collectibleContracts;\n      }\n      const contractInformation = await this.getCollectibleContractInformation(address);\n      const { name, symbol, image_url, description, total_supply } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Oherwise at least name and symbol from contract is needed\n      if ((detection && !image_url) || Object.keys(contractInformation).length === 0) {\n        return collectibleContracts;\n      }\n      const newEntry: CollectibleContract = {\n        address,\n        description,\n        logo: image_url,\n        name,\n        symbol,\n        totalSupply: total_supply,\n      };\n      const newCollectibleContracts = [...collectibleContracts, newEntry];\n      const addressCollectibleContracts = allCollectibleContracts[selectedAddress];\n      const newAddressCollectibleContracts = {\n        ...addressCollectibleContracts,\n        ...{ [networkType]: newCollectibleContracts },\n      };\n      const newAllCollectibleContracts = {\n        ...allCollectibleContracts,\n        ...{ [selectedAddress]: newAddressCollectibleContracts },\n      };\n      this.update({\n        allCollectibleContracts: newAllCollectibleContracts,\n        collectibleContracts: newCollectibleContracts,\n      });\n      return newCollectibleContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list and saves it in ignored collectibles list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - Token identifier of the collectible\n   */\n  private removeAndIgnoreIndividualCollectible(address: string, tokenId: number) {\n    address = toChecksumAddress(address);\n    const { allCollectibles, collectibles, ignoredCollectibles } = this.state;\n    const { networkType, selectedAddress } = this.config;\n    const newIgnoredCollectibles = [...ignoredCollectibles];\n    const newCollectibles = collectibles.filter((collectible) => {\n      if (collectible.address === address && collectible.tokenId === tokenId) {\n        const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);\n        !alreadyIgnored && newIgnoredCollectibles.push(collectible);\n        return false;\n      }\n      return true;\n    });\n    const addressCollectibles = allCollectibles[selectedAddress];\n    const newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n    const newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n    this.update({\n      allCollectibles: newAllCollectibles,\n      collectibles: newCollectibles,\n      ignoredCollectibles: newIgnoredCollectibles,\n    });\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - Token identifier of the collectible\n   */\n  private removeIndividualCollectible(address: string, tokenId: number) {\n    address = toChecksumAddress(address);\n    const { allCollectibles, collectibles } = this.state;\n    const { networkType, selectedAddress } = this.config;\n    const newCollectibles = collectibles.filter(\n      (collectible) => !(collectible.address === address && collectible.tokenId === tokenId),\n    );\n    const addressCollectibles = allCollectibles[selectedAddress];\n    const newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n    const newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n    this.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });\n  }\n\n  /**\n   * Removes a collectible contract to the stored collectible contracts list\n   *\n   * @param address - Hex address of the collectible contract\n   * @returns - Promise resolving to the current collectible contracts list\n   */\n  private removeCollectibleContract(address: string): CollectibleContract[] {\n    address = toChecksumAddress(address);\n    const { allCollectibleContracts, collectibleContracts } = this.state;\n    const { networkType, selectedAddress } = this.config;\n    const newCollectibleContracts = collectibleContracts.filter(\n      (collectibleContract) => !(collectibleContract.address === address),\n    );\n    const addressCollectibleContracts = allCollectibleContracts[selectedAddress];\n    const newAddressCollectibleContracts = {\n      ...addressCollectibleContracts,\n      ...{ [networkType]: newCollectibleContracts },\n    };\n    const newAllCollectibleContracts = {\n      ...allCollectibleContracts,\n      ...{ [selectedAddress]: newAddressCollectibleContracts },\n    };\n    this.update({\n      allCollectibleContracts: newAllCollectibleContracts,\n      collectibleContracts: newCollectibleContracts,\n    });\n    return newCollectibleContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'AssetsController';\n\n  /**\n   * List of required sibling controllers this controller needs to function\n   */\n  requiredControllers = ['AssetsContractController', 'NetworkController', 'PreferencesController'];\n\n  /**\n   * Creates a AssetsController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(config?: Partial<BaseConfig>, state?: Partial<AssetsState>) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: 'mainnet',\n      selectedAddress: '',\n    };\n    this.defaultState = {\n      allCollectibleContracts: {},\n      allCollectibles: {},\n      allTokens: {},\n      collectibleContracts: [],\n      collectibles: [],\n      ignoredCollectibles: [],\n      ignoredTokens: [],\n      suggestedAssets: [],\n      tokens: [],\n    };\n    this.initialize();\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve collectible information\n   *\n   * @param openSeaApiKey - OpenSea API key\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Adds a token to the stored token list\n   *\n   * @param address - Hex address of the token contract\n   * @param symbol - Symbol of the token\n   * @param decimals - Number of decimals the token uses\n   * @param image - Image of the token\n   * @returns - Current token list\n   */\n  async addToken(address: string, symbol: string, decimals: number, image?: string): Promise<Token[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumAddress(address);\n      const { allTokens, tokens } = this.state;\n      const { networkType, selectedAddress } = this.config;\n      const newEntry: Token = { address, symbol, decimals, image };\n      const previousEntry = tokens.find((token) => token.address === address);\n      if (previousEntry) {\n        const previousIndex = tokens.indexOf(previousEntry);\n        tokens[previousIndex] = newEntry;\n      } else {\n        tokens.push(newEntry);\n      }\n      const addressTokens = allTokens[selectedAddress];\n      const newAddressTokens = { ...addressTokens, ...{ [networkType]: tokens } };\n      const newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n      const newTokens = [...tokens];\n      this.update({ allTokens: newAllTokens, tokens: newTokens });\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - Asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - Asset type\n   * @returns - Object containing a promise resolving to the suggestedAsset address if accepted\n   */\n  async watchAsset(asset: Token, type: string): Promise<AssetSuggestionResult> {\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: random(),\n      status: 'pending',\n      time: Date.now(),\n      type,\n    };\n    try {\n      switch (type) {\n        case 'ERC20':\n          validateTokenToWatch(asset);\n          break;\n        default:\n          throw new Error(`Asset of type ${type} not supported`);\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n      return Promise.reject(error);\n    }\n\n    const result: Promise<string> = new Promise((resolve, reject) => {\n      this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta: SuggestedAssetMeta) => {\n        switch (meta.status) {\n          case 'accepted':\n            return resolve(meta.asset.address);\n          case 'rejected':\n            return reject(new Error('User rejected to watch the asset.'));\n          case 'failed':\n            return reject(new Error(meta.error!.message));\n        }\n      });\n    });\n    const { suggestedAssets } = this.state;\n    suggestedAssets.push(suggestedAssetMeta);\n    this.update({ suggestedAssets: [...suggestedAssets] });\n    this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);\n    return { result, suggestedAssetMeta };\n  }\n\n  /**\n   * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,\n   * adding the asset to corresponding asset state. In this case ERC20 tokens.\n   * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.\n   *\n   * @param suggestedAssetID - ID of the suggestedAsset to accept\n   * @returns - Promise resolving when this operation completes\n   */\n  async acceptWatchAsset(suggestedAssetID: string): Promise<void> {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);\n    const suggestedAssetMeta = suggestedAssets[index];\n    try {\n      switch (suggestedAssetMeta.type) {\n        case 'ERC20':\n          const { address, symbol, decimals, image } = suggestedAssetMeta.asset;\n          await this.addToken(address, symbol, decimals, image);\n          suggestedAssetMeta.status = 'accepted';\n          this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n          break;\n        default:\n          throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n    }\n    const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Rejects a watchAsset request based on its ID by setting its status to \"rejected\"\n   * and emitting a `<suggestedAssetMeta.id>:finished` hub event.\n   *\n   * @param suggestedAssetID - ID of the suggestedAsset to accept\n   */\n  rejectWatchAsset(suggestedAssetID: string) {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);\n    const suggestedAssetMeta = suggestedAssets[index];\n    if (!suggestedAssetMeta) {\n      return;\n    }\n    suggestedAssetMeta.status = 'rejected';\n    this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n    const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - The collectible identifier\n   * @param opts - Collectible optional information (name, image and description)\n   * @param detection? - Whether the collectible is manually added or autodetected\n   * @returns - Promise resolving to the current collectible list\n   */\n  async addCollectible(address: string, tokenId: number, opts?: CollectibleInformation, detection?: boolean) {\n    address = toChecksumAddress(address);\n    const newCollectibleContracts = await this.addCollectibleContract(address, detection);\n    // If collectible contract was not added, do not add individual collectible\n    const collectibleContract = newCollectibleContracts.find((contract) => contract.address === address);\n    // If collectible contract information, add individual collectible\n    if (collectibleContract) {\n      await this.addIndividualCollectible(address, tokenId, opts);\n    }\n  }\n\n  /**\n   * Removes a token from the stored token list and saves it in ignored tokens list\n   *\n   * @param address - Hex address of the token contract\n   */\n  removeAndIgnoreToken(address: string) {\n    address = toChecksumAddress(address);\n    const { allTokens, tokens, ignoredTokens } = this.state;\n    const { networkType, selectedAddress } = this.config;\n    const newIgnoredTokens = [...ignoredTokens];\n    const newTokens = tokens.filter((token) => {\n      if (token.address === address) {\n        const alreadyIgnored = newIgnoredTokens.find((t) => t.address === address);\n        !alreadyIgnored && newIgnoredTokens.push(token);\n        return false;\n      }\n      return true;\n    });\n    const addressTokens = allTokens[selectedAddress];\n    const newAddressTokens = { ...addressTokens, ...{ [networkType]: newTokens } };\n    const newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n    this.update({ allTokens: newAllTokens, tokens: newTokens, ignoredTokens: newIgnoredTokens });\n  }\n\n  /**\n   * Removes a token from the stored token list\n   *\n   * @param address - Hex address of the token contract\n   */\n  removeToken(address: string) {\n    address = toChecksumAddress(address);\n    const { allTokens, tokens } = this.state;\n    const { networkType, selectedAddress } = this.config;\n    const newTokens = tokens.filter((token) => token.address !== address);\n    const addressTokens = allTokens[selectedAddress];\n    const newAddressTokens = { ...addressTokens, ...{ [networkType]: newTokens } };\n    const newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n    this.update({ allTokens: newAllTokens, tokens: newTokens });\n  }\n\n  /**\n   * Removes a collectible from the stored token list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - Token identifier of the collectible\n   */\n  removeCollectible(address: string, tokenId: number) {\n    address = toChecksumAddress(address);\n    this.removeIndividualCollectible(address, tokenId);\n    const { collectibles } = this.state;\n    const remainingCollectible = collectibles.find((collectible) => collectible.address === address);\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes a collectible from the stored token list and saves it in ignored collectibles list\n   *\n   * @param address - Hex address of the collectible contract\n   * @param tokenId - Token identifier of the collectible\n   */\n  removeAndIgnoreCollectible(address: string, tokenId: number) {\n    address = toChecksumAddress(address);\n    this.removeAndIgnoreIndividualCollectible(address, tokenId);\n    const { collectibles } = this.state;\n    const remainingCollectible = collectibles.find((collectible) => collectible.address === address);\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes all tokens from the ignored list\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [] });\n  }\n\n  /**\n   * Removes all collectibles from the ignored list\n   */\n  clearIgnoredCollectibles() {\n    this.update({ ignoredCollectibles: [] });\n  }\n\n  /**\n   * Extension point called if and when this controller is composed\n   * with other controllers using a ComposableController\n   */\n  onComposed() {\n    super.onComposed();\n    const preferences = this.context.PreferencesController as PreferencesController;\n    const network = this.context.NetworkController as NetworkController;\n    preferences.subscribe(({ selectedAddress }) => {\n      const { allCollectibleContracts, allCollectibles, allTokens } = this.state;\n      const { networkType } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        collectibleContracts:\n          (allCollectibleContracts[selectedAddress] && allCollectibleContracts[selectedAddress][networkType]) || [],\n        collectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],\n        tokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || [],\n      });\n    });\n    network.subscribe(({ provider }) => {\n      const { allCollectibleContracts, allCollectibles, allTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const networkType = provider.type;\n      this.configure({ networkType });\n      this.update({\n        collectibleContracts:\n          (allCollectibleContracts[selectedAddress] && allCollectibleContracts[selectedAddress][networkType]) || [],\n        collectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],\n        tokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || [],\n      });\n    });\n  }\n}\n\nexport default AssetsController;\n"]}