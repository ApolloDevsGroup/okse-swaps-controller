{"version":3,"file":"PersonalMessageManager.js","sourceRoot":"","sources":["../../src/message-manager/PersonalMessageManager.ts"],"names":[],"mappings":";;;AAAA,kCAAwE;AACxE,qEAKkC;AAElC,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AA8ClC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,gCAI3C;IAJD;;QAKE;;WAEG;QACH,SAAI,GAAG,wBAAwB,CAAC;IAoElC,CAAC;IAlEC;;;;;;;OAOG;IACH,yBAAyB,CAAC,aAAoC,EAAE,GAAqB;QACnF,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,8BAAuB,CAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YAChE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAqB,EAAE,EAAE;gBAC/D,QAAQ,IAAI,CAAC,MAAM,EAAE;oBACnB,KAAK,QAAQ;wBACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAC9B,KAAK,UAAU;wBACb,OAAO,MAAM,CAAC,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC,CAAC;oBAClG;wBACE,OAAO,MAAM,CACX,IAAI,KAAK,CAAC,yDAAyD,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,EAAE,CAAC,CACpG,CAAC;iBACL;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;;OASG;IACH,oBAAoB,CAAC,aAAoC,EAAE,GAAqB;QAC9E,IAAI,GAAG,EAAE;YACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;SACnC;QACD,aAAa,CAAC,IAAI,GAAG,2BAAoB,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC9D,MAAM,SAAS,GAAG,MAAM,EAAE,CAAC;QAC3B,MAAM,WAAW,GAAoB;YACnC,EAAE,EAAE,SAAS;YACb,aAAa;YACb,MAAM,EAAE,YAAY;YACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;YAChB,IAAI,EAAE,eAAe;SACtB,CAAC;QACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAAO,aAAa,GAAK,EAAE,UAAU,EAAE,SAAS,EAAE,EAAG,CAAC;QACvF,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,qBAAqB,CAAC,aAA4C;QAChE,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA5ED,wDA4EC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import { validateSignMessageData, normalizeMessageData } from '../util';\nimport AbstractMessageManager, {\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\nconst random = require('uuid/v1');\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'personal_sign' type signature request.\n * These are created when a signature for a personal_sign call is requested.\n *\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the personal_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'personal_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface PersonalMessage extends AbstractMessage {\n  messageParams: PersonalMessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved.\n *\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved\n * plus data added by MetaMask.\n *\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParamsMetamask extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class PersonalMessageManager extends AbstractMessageManager<\n  PersonalMessage,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'PersonalMessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message is approved\n   * @param req? - The original request object possibly containing the origin\n   * @returns - Promise resolving to the raw data of the signature request\n   */\n  addUnapprovedMessageAsync(messageParams: PersonalMessageParams, req?: OriginalRequest): Promise<string> {\n    return new Promise((resolve, reject) => {\n      validateSignMessageData(messageParams);\n      const messageId = this.addUnapprovedMessage(messageParams, req);\n      this.hub.once(`${messageId}:finished`, (data: PersonalMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig);\n          case 'rejected':\n            return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));\n          default:\n            return reject(\n              new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message\n   * is approved\n   * @param req? - The original request object possibly containing the origin\n   * @returns - The id of the newly created message\n   */\n  addUnapprovedMessage(messageParams: PersonalMessageParams, req?: OriginalRequest) {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: PersonalMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'personal_sign',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, { ...messageParams, ...{ metamaskId: messageId } });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams\n   *\n   * @param messageParams - The messageParams to modify\n   * @returns - Promise resolving to the messageParams with the metamaskId property removed\n   */\n  prepMessageForSigning(messageParams: PersonalMessageParamsMetamask): Promise<PersonalMessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default PersonalMessageManager;\n"]}