{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../../src/keyring/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import { toChecksumAddress } from 'ethereumjs-util';\nimport {\n  normalize as normalizeAddress,\n  signTypedData,\n  signTypedData_v4,\n  signTypedDataLegacy,\n} from 'eth-sig-util';\nimport BaseController, { BaseConfig, BaseState, Listener } from '../BaseController';\nimport PreferencesController from '../user/PreferencesController';\nimport { Transaction } from '../transaction/TransactionController';\nimport { PersonalMessageParams } from '../message-manager/PersonalMessageManager';\nimport { TypedMessageParams } from '../message-manager/TypedMessageManager';\n\nconst Keyring = require('eth-keyring-controller');\nconst { Mutex } = require('await-semaphore');\nconst Wallet = require('ethereumjs-wallet');\nconst ethUtil = require('ethereumjs-util');\nconst importers = require('ethereumjs-wallet/thirdparty');\n\nconst privates = new WeakMap();\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n}\n\n/**\n * @type KeyringObject\n *\n * Keyring object\n *\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @function getAccounts - Get associated accounts\n */\nexport interface KeyringObject {\n  type: string;\n  accounts: string[];\n  getAccounts(): string[];\n}\n\n/**\n * @type KeyringState\n *\n * Keyring controller state\n *\n * @property vault - Encrypted string representing keyring data\n * @property keyrings - Group of accounts\n */\nexport interface KeyringState extends BaseState {\n  vault?: string;\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringMemState\n *\n * Keyring mem controller state\n *\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n */\nexport interface KeyringMemState extends BaseState {\n  isUnlocked: boolean;\n  keyringTypes: string[];\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringConfig\n *\n * Keyring controller configuration\n *\n * @property encryptor - Keyring encryptor\n */\nexport interface KeyringConfig extends BaseConfig {\n  encryptor?: any;\n}\n\n/**\n * @type Keyring\n *\n * Keyring object to return in fullUpdate\n *\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @property index - Associated index\n */\nexport interface Keyring {\n  accounts: string[];\n  type: string;\n  index?: number;\n}\n\n/**\n * Controller responsible for establishing and managing user identity\n */\nexport class KeyringController extends BaseController<KeyringConfig, KeyringState> {\n  private mutex = new Mutex();\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'KeyringController';\n\n  /**\n   * List of required sibling controllers this controller needs to function\n   */\n  requiredControllers = ['PreferencesController'];\n\n  /**\n   * Creates a KeyringController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor(config?: Partial<KeyringConfig>, state?: Partial<KeyringState>) {\n    super(config, state);\n    privates.set(this, { keyring: new Keyring(Object.assign({ initState: state }, config)) });\n    this.defaultState = {\n      ...privates.get(this).keyring.store.getState(),\n      keyrings: [],\n    };\n    this.initialize();\n    this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring\n   *\n   * @returns - Promise resolving to current state when the account is added\n   */\n  async addNewAccount(): Promise<KeyringMemState> {\n    const preferences = this.context.PreferencesController as PreferencesController;\n    const primaryKeyring = privates.get(this).keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await privates.get(this).keyring.getAccounts();\n    await privates.get(this).keyring.addNewAccount(primaryKeyring);\n    const newAccounts = await privates.get(this).keyring.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    preferences.updateIdentities(newAccounts);\n    newAccounts.forEach((selectedAddress: string) => {\n      if (!oldAccounts.includes(selectedAddress)) {\n        preferences.update({ selectedAddress });\n      }\n    });\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences\n   *\n   * @returns - Promise resolving to current state when the account is added\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringMemState> {\n    const primaryKeyring = privates.get(this).keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await privates.get(this).keyring.addNewAccount(primaryKeyring);\n    await this.verifySeedPhrase();\n    return this.fullUpdate();\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase\n   *\n   * @param password - Password to unlock keychain\n   * @param seed - Seed phrase to restore keychain\n   * @returns - Promise resolving to th restored keychain object\n   */\n  async createNewVaultAndRestore(password: string, seed: string) {\n    const preferences = this.context.PreferencesController as PreferencesController;\n    const releaseLock = await this.mutex.acquire();\n    try {\n      preferences.updateIdentities([]);\n      const vault = await privates.get(this).keyring.createNewVaultAndRestore(password, seed);\n      preferences.updateIdentities(await privates.get(this).keyring.getAccounts());\n      preferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains\n   *\n   * @param password - Password to unlock the new vault\n   * @returns - Newly-created keychain object\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const preferences = this.context.PreferencesController as PreferencesController;\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const vault = await privates.get(this).keyring.createNewVaultAndKeychain(password);\n      preferences.updateIdentities(await privates.get(this).keyring.getAccounts());\n      preferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Returns the status of the vault\n   *\n   * @returns - Boolean returning true if the vault is unlocked\n   */\n  isUnlocked(): boolean {\n    return privates.get(this).keyring.memStore.getState().isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring\n   *\n   * @param password - Password of the keyring\n   * @returns - Promise resolving to the seed phrase\n   */\n  exportSeedPhrase(password: string) {\n    if (privates.get(this).keyring.password === password) {\n      return privates.get(this).keyring.keyrings[0].mnemonic;\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address\n   *\n   * @param password - Password of the keyring\n   * @param address - Address to export\n   * @returns - Promise resolving to the private key for an address\n   */\n  exportAccount(password: string, address: string): Promise<string> {\n    if (privates.get(this).keyring.password === password) {\n      return privates.get(this).keyring.exportAccount(address);\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring\n   *\n   * @returns - A promise resolving to an array of addresses\n   */\n  getAccounts(): Promise<string[]> {\n    return privates.get(this).keyring.getAccounts();\n  }\n\n  /**\n   * Imports an account with the specified import strategy\n   *\n   * @param strategy - Import strategy name\n   * @param args - Array of arguments to pass to the underlying stategy\n   * @returns - Promise resolving to current state when the import is complete\n   */\n  async importAccountWithStrategy(strategy: string, args: any[]): Promise<KeyringMemState> {\n    let privateKey;\n    const preferences = this.context.PreferencesController as PreferencesController;\n    switch (strategy) {\n      case 'privateKey':\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        const prefixed = ethUtil.addHexPrefix(importedKey);\n        if (!ethUtil.isValidPrivate(ethUtil.toBuffer(prefixed))) {\n          throw new Error('Cannot import invalid private key.');\n        }\n        privateKey = ethUtil.stripHexPrefix(prefixed);\n        break;\n      case 'json':\n        let wallet;\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || Wallet.fromV3(input, password, true);\n        }\n        privateKey = ethUtil.bufferToHex(wallet.getPrivateKey());\n        break;\n    }\n    const newKeyring = await privates.get(this).keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);\n    const accounts = await newKeyring.getAccounts();\n    const allAccounts = await privates.get(this).keyring.getAccounts();\n    preferences.updateIdentities(allAccounts);\n    preferences.update({ selectedAddress: accounts[0] });\n    return this.fullUpdate();\n  }\n\n  /**\n   * Removes an account from keyring state\n   *\n   * @param address - Address of the account to remove\n   * @returns - Promise resolving current state when this account removal completes\n   */\n  async removeAccount(address: string): Promise<KeyringMemState> {\n    const preferences = this.context.PreferencesController as PreferencesController;\n    preferences.removeIdentity(address);\n    await privates.get(this).keyring.removeAccount(address);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet\n   *\n   * @returns - Promise resolving to current state\n   */\n  setLocked(): Promise<KeyringMemState> {\n    return privates.get(this).keyring.setLocked();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring\n   *\n   * @param messageParams - PersonalMessageParams object to sign\n   * @returns - Promise resolving to a signed message string\n   */\n  signMessage(messageParams: PersonalMessageParams) {\n    return privates.get(this).keyring.signMessage(messageParams);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring\n   *\n   * @param messageParams - PersonalMessageParams object to sign\n   * @returns - Promise resolving to a signed message string\n   */\n  signPersonalMessage(messageParams: PersonalMessageParams) {\n    return privates.get(this).keyring.signPersonalMessage(messageParams);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring\n   *\n   * @param messageParams - TypedMessageParams object to sign\n   * @param version - Compatibility version EIP712\n   * @returns - Promise resolving to a signed message string or an error if any\n   */\n  async signTypedMessage(messageParams: TypedMessageParams, version: string) {\n    try {\n      const address = normalizeAddress(messageParams.from);\n      const { password } = privates.get(this).keyring;\n      const privateKey = await this.exportAccount(password, address);\n      const privateKeyBuffer = ethUtil.toBuffer(ethUtil.addHexPrefix(privateKey));\n      switch (version) {\n        case 'V1':\n          // signTypedDataLegacy will throw if the data is invalid.\n          return signTypedDataLegacy(privateKeyBuffer, { data: messageParams.data as any });\n        case 'V3':\n          return signTypedData(privateKeyBuffer, { data: JSON.parse(messageParams.data as string) });\n        case 'V4':\n          return signTypedData_v4(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n      }\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring\n   *\n   * @param transaction - Transaction object to sign\n   * @param from - Address to sign from, should be in keychain\n   * @returns - Promise resolving to a signed transaction string\n   */\n  signTransaction(transaction: Transaction, from: string) {\n    return privates.get(this).keyring.signTransaction(transaction, from);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings\n   *\n   * @param password - Password to unlock the keychain\n   * @returns - Promise resolving to the current state\n   */\n  async submitPassword(password: string): Promise<KeyringMemState> {\n    const preferences = this.context.PreferencesController as PreferencesController;\n    await privates.get(this).keyring.submitPassword(password);\n    const accounts = await privates.get(this).keyring.getAccounts();\n    await preferences.syncIdentities(accounts);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds new listener to be notified of state changes\n   *\n   * @param listener - Callback triggered when state changes\n   */\n  subscribe(listener: Listener<KeyringState>) {\n    privates.get(this).keyring.store.subscribe(listener);\n  }\n\n  /**\n   * Removes existing listener from receiving state changes\n   *\n   * @param listener - Callback to remove\n   * @returns - True if a listener is found and unsubscribed\n   */\n  unsubscribe(listener: Listener<KeyringState>) {\n    return privates.get(this).keyring.store.unsubscribe(listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is locked\n   *\n   * @param listener - Callback triggered when wallet is locked\n   * @returns - EventEmitter if listener added\n   */\n  onLock(listener: () => void) {\n    return privates.get(this).keyring.on('lock', listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is unlocked\n   *\n   * @param listener - Callback triggered when wallet is unlocked\n   * @returns - EventEmitter if listener added\n   */\n  onUnlock(listener: () => void) {\n    return privates.get(this).keyring.on('unlock', listener);\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts\n   *\n   * @returns - Promise resolving if the verification succeeds\n   */\n  async verifySeedPhrase(): Promise<string> {\n    const primaryKeyring = privates.get(this).keyring.getKeyringsByType(KeyringTypes.hd)[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    const seedWords = (await primaryKeyring.serialize()).mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    const TestKeyringClass = privates.get(this).keyring.getKeyringClassForType(KeyringTypes.hd);\n    const testKeyring = new TestKeyringClass({ mnemonic: seedWords, numberOfAccounts: accounts.length });\n    const testAccounts = await testKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Update keyrings in state and calls KeyringController fullUpdate method returning current state\n   *\n   * @returns - Promise resolving to current state\n   */\n  async fullUpdate(): Promise<KeyringMemState> {\n    const keyrings: Keyring[] = await Promise.all<Keyring>(\n      privates.get(this).keyring.keyrings.map(\n        async (keyring: KeyringObject, index: number): Promise<Keyring> => {\n          const keyringAccounts = await keyring.getAccounts();\n          const accounts = Array.isArray(keyringAccounts)\n            ? keyringAccounts.map((address) => toChecksumAddress(address))\n            : /* istanbul ignore next */ [];\n          return {\n            accounts,\n            index,\n            type: keyring.type,\n          };\n        },\n      ),\n    );\n    this.update({ keyrings: [...keyrings] });\n    return privates.get(this).keyring.fullUpdate();\n  }\n}\n\nexport default KeyringController;\n"]}